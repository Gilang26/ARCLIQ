<script>
let provider, signer;

// === CONFIG ===
const ROUTER = "0xbdcb8cba012bc0c979875fef879b05e050e76d7d";
const NATIVE_USDC = "0x3600000000000000000000000000000000000000";

const ROUTER_ABI = [
  "function addLiquidity(address tokenA, address tokenB, uint256 amtA, uint256 amtB) returns (address)",
  "function addLiquidityNative(address token, uint256 amtToken) payable returns (address)",
  "function swap(address tokenIn, address tokenOut, uint256 amountIn) returns (uint256)"
];

// === UI HELPERS ===
function log(msg){
  const box = document.getElementById("logs");
  box.value += msg + "\n";
  box.scrollTop = box.scrollHeight;
}

function setProcessing(btn, isLoading, text){
  if(isLoading){
    btn.disabled = true;
    btn.innerText = text;
  } else {
    btn.disabled = false;
    btn.innerText = btn.dataset.label;
  }
}

// === WALLET CONNECT ===
document.getElementById("connectBtn").addEventListener("click", async ()=>{
  try{
    if (!window.ethereum){
      alert("MetaMask not found");
      return;
    }

    provider = new ethers.BrowserProvider(window.ethereum);
    signer = await provider.getSigner();

    const addr = await signer.getAddress();
    const chain = await signer.provider.getNetwork();

    log("✅ Connected: " + addr + " (chain " + chain.chainId + ")");

    document.getElementById("connectBtn").innerText = "Disconnect";
  }catch(e){
    log("❌ Connect failed: " + e.message);
  }
});

// === APPROVE VISIBILITY (HIDE WHEN NATIVE USDC USED) ===
function checkNative(){
  const A = document.getElementById("pairTokenA").value.trim().toLowerCase();
  const B = document.getElementById("pairTokenB").value.trim().toLowerCase();
  const hide = (A === NATIVE_USDC || B === NATIVE_USDC);
  document.getElementById("approveA").style.display = hide ? "none" : "inline-block";
  document.getElementById("approveB").style.display = hide ? "none" : "inline-block";
}

document.getElementById("pairTokenA").addEventListener("input", checkNative);
document.getElementById("pairTokenB").addEventListener("input", checkNative);

// === ADD LP ===
document.getElementById("addLpBtn").addEventListener("click", async ()=>{
  try{
    if(!signer){ return alert("Connect wallet first"); }

    const A = document.getElementById("pairTokenA").value.trim();
    const B = document.getElementById("pairTokenB").value.trim();
    const a = document.getElementById("amtA").value.trim();
    const b = document.getElementById("amtB").value.trim();

    const router = new ethers.Contract(ROUTER, ROUTER_ABI, signer);
    const btn = document.getElementById("addLpBtn");
    setProcessing(btn, true, "Adding LP...");

    let tx;
    if (A.toLowerCase() === NATIVE_USDC){
      tx = await router.addLiquidityNative(B, b, { value: a });
    } else if (B.toLowerCase() === NATIVE_USDC){
      tx = await router.addLiquidityNative(A, a, { value: b });
    } else {
      tx = await router.addLiquidity(A, B, a, b);
    }

    log("⏳ addLiquidity tx: " + tx.hash);
    await tx.wait();
    log("✅ Liquidity added!");
    setProcessing(btn, false);
  }catch(e){
    log("❌ addLiquidity failed: " + (e.message || e));
    setProcessing(document.getElementById("addLpBtn"), false);
  }
});

// === SWAP ===
document.getElementById("swapBtn").addEventListener("click", async ()=>{
  try{
    if(!signer){ return alert("Connect wallet first"); }

    const tokenIn = document.getElementById("swapA").value.trim();
    const tokenOut = document.getElementById("swapB").value.trim();
    const amt = document.getElementById("swapAmount").value.trim();

    const router = new ethers.Contract(ROUTER, ROUTER_ABI, signer);
    const btn = document.getElementById("swapBtn");
    setProcessing(btn, true, "Swapping...");

    const tx = await router.swap(tokenIn, tokenOut, amt);
    log("⏳ swap tx: " + tx.hash);
    await tx.wait();
    log("✅ Swap Success!");
    setProcessing(btn, false);
  }catch(e){
    log("❌ swap failed: " + (e.message || e));
    setProcessing(document.getElementById("swapBtn"), false);
  }
});
</script>
