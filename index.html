<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ARCLIQ ‚Äî Minimal DEX (Uniswap-like)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#ffffff; --panel:#ffffff; --muted:#6b7280; --accent:#7c3aed; --glass: rgba(16,24,40,0.03);
  }
  *{box-sizing:border-box}
  body{font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(180deg,#f6f8fb 0%, #ffffff 100%);margin:0;color:#0f172a}
  .wrap{max-width:980px;margin:28px auto;padding:0 18px}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:28px}
  .brand{font-weight:600;font-size:20px;letter-spacing:0.4px}
  .sub{color:var(--muted);font-size:12px}
  .container{display:flex;gap:20px}
  .card{flex:1;background:var(--panel);border-radius:12px;padding:18px;box-shadow:0 6px 20px rgba(16,24,40,0.06)}
  h2{margin:0 0 8px;font-weight:600;font-size:16px}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  .row{display:flex;gap:8px;margin-bottom:10px}
  input,select,button{font-family:inherit;font-size:14px;border-radius:10px;padding:12px;border:1px solid #e6eef6}
  input::placeholder{color:#cbd5e1}
  .full{width:100%}
  button.primary{background:var(--accent);color:#fff;border:0;padding:12px 14px;border-radius:10px;cursor:pointer}
  button.ghost{background:transparent;border:1px solid #e6eef6;color:var(--muted);cursor:pointer;padding:10px 12px;border-radius:10px}
  .muted{color:var(--muted);font-size:13px}
  .small{font-size:12px;color:#94a3b8}
  #logs{margin-top:12px;background:#0b1220;color:#bfeef9;padding:12px;border-radius:10px;min-height:120px;white-space:pre-wrap;overflow:auto}
  @media(max-width:900px){.container{flex-direction:column}}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div class="brand">ARCLIQ</div>
        <div class="sub">Powered by ARC Network (Testnet) ‚Äî minimal Uniswap-like</div>
      </div>
      <div>
        <button id="connectBtn" class="primary">üîó Connect MetaMask</button>
      </div>
    </header>

    <div class="container">
      <!-- Swap -->
      <div class="card">
        <h2>Swap</h2>
        <div class="small muted">Swap between USDC ‚Üî ARCLIQ</div>

        <div style="margin-top:12px">
          <label>Direction</label>
          <select id="swapDir" class="full" style="margin-bottom:10px;padding:10px">
            <option value="usdc->token">USDC ‚Üí ARCLIQ</option>
            <option value="token->usdc">ARCLIQ ‚Üí USDC</option>
          </select>

          <label>Amount (input)</label>
          <input id="swapAmount" placeholder="amount in wei (1e18 = 1 token)" class="full" />

          <div style="display:flex;gap:8px;margin-top:12px">
            <button id="approveSwapBtn" class="ghost">Approve Input</button>
            <button id="swapBtn" class="primary">üîÅ Swap</button>
          </div>

          <div class="small muted" style="margin-top:10px">Tip: approve input token before swap (unless input is native USDC).</div>
        </div>
      </div>

      <!-- Add Liquidity -->
      <div class="card">
        <h2>Add Liquidity</h2>
        <div class="small muted">Create pair and add liquidity (USDC ‚Üî ARCLIQ)</div>

        <div style="margin-top:12px">
          <label>Token A (base)</label>
          <input id="pairTokenA" value="0x3600000000000000000000000000000000000000" class="full" />

          <label style="margin-top:8px">Token B</label>
          <input id="pairTokenB" value="0x3Be143cf70ACb16C7208673F1D3D2Ae403ebaEB3" class="full" />

          <div style="display:flex;gap:8px;margin-top:12px">
            <button id="createPairBtn" class="ghost">üß± Create Pair</button>
            <button id="getPairBtn" class="ghost">üîé Get Pair</button>
          </div>

          <label style="margin-top:12px">Amount A (wei)</label>
          <input id="amtA" value="1000000000000000000" class="full" />

          <label style="margin-top:8px">Amount B (wei)</label>
          <input id="amtB" value="1000000000000000000" class="full" />

          <div style="display:flex;gap:8px;margin-top:12px">
            <button id="approveA" class="ghost">Approve A</button>
            <button id="approveB" class="ghost">Approve B</button>
            <button id="addLpBtn" class="primary">‚ûï Add Liquidity</button>
          </div>

          <div id="pairAddr" class="small muted" style="margin-top:10px"></div>
        </div>
      </div>
    </div>

    <div style="margin-top:18px" class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="muted">Status & logs</div>
        <div id="walletInfo" class="small muted">Not connected</div>
      </div>
      <pre id="logs">Ready</pre>
    </div>

  </div>

<script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.umd.min.js"></script>
<script>
/* === QUICK DEBUG catcher (writes errors to #logs so mobile browser can show them) === */
window.onerror = function (msg, url, line, col, error) {
  const logs = document.getElementById("logs");
  if (logs) {
    logs.textContent += "\\nJS ERROR: " + msg + " @ " + line + ":" + col + (error && error.stack ? "\\nSTACK: " + error.stack : "");
    logs.scrollTop = logs.scrollHeight;
  }
};

/* === CONFIG ‚Äî replace addresses with the real ones you deployed === */
/* Factory left as previous deploy (keep if correct). If different, change it. */
const FACTORY = "0xA7e452f27836AED20081345B9149d4D1a722BF2a";
const ROUTER  = "0xbdcb8cba012bc0c979875fef879b05e050e76d7d"; // <- router you gave
const NATIVE_USDC = "0x3600000000000000000000000000000000000000"; // USDC native (faucet)
const TOKEN    = "0x3Be143cf70ACb16C7208673F1D3D2Ae403ebaEB3"; // ARCLIQ

/* === ABIs (matching signatures you provided) === */
const ERC20_ABI = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function approve(address,uint256) returns (bool)",
  "function transferFrom(address,address,uint256) returns (bool)",
  "function balanceOf(address) view returns (uint)"
];
const FACTORY_ABI = [
  "function createPair(address,address) returns (address)",
  "function getPair(address,address) view returns (address)"
];
const ROUTER_ABI = [
  "function addLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB) external returns(address)",
  "function addLiquidityNative(address token, uint256 amountToken) external payable returns(address)",
  "function swap(address tokenIn, address tokenOut, uint256 amountIn) external returns(uint256)"
];

/* === state & UI refs === */
let provider=null, signer=null, userAddress=null;
const connectBtn=document.getElementById("connectBtn");
const walletInfo=document.getElementById("walletInfo");
const logs=document.getElementById("logs");

function log(msg){ logs.textContent += "\\n" + msg; logs.scrollTop = logs.scrollHeight; }
function setProcessing(btn, isProcessing, text){
  if(isProcessing){ btn.dataset.orig = btn.textContent; btn.textContent = text || "Processing..."; btn.disabled = true; }
  else { btn.textContent = btn.dataset.orig || btn.textContent; btn.disabled = false; }
}

/* UI update connect/disconnect */
function updateUIConnected(addr, chainId){
  connectBtn.textContent = "‚ùå Disconnect";
  walletInfo.textContent = `${addr} | chain ${chainId}`;
}
function updateUIDisconnected(){
  connectBtn.textContent = "üîó Connect MetaMask";
  walletInfo.textContent = "Not connected";
}

/* Connect / Disconnect */
async function connectWallet(){
  try{
    if(!window.ethereum) { alert("Install MetaMask"); return; }
    provider = new ethers.BrowserProvider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    signer = await provider.getSigner();
    userAddress = await signer.getAddress();
    const net = await provider.getNetwork();
    updateUIConnected(userAddress, net.chainId);
    log("‚úÖ Connected: " + userAddress + " (chain " + net.chainId + ")");
    localStorage.setItem("arcliq_connected","1");
  }catch(e){ log("‚ùå Connect failed: " + (e.message || e)); }
}
function disconnectWallet(){
  provider = null; signer = null; userAddress = null;
  updateUIDisconnected();
  localStorage.removeItem("arcliq_connected");
  log("‚ùå Disconnected (UI cleared)");
}

/* Toggle connect */
connectBtn.addEventListener("click", async ()=>{
  if(!signer){ await connectWallet(); } else { disconnectWallet(); }
});

/* auto reconnect if flagged */
if(localStorage.getItem("arcliq_connected")==="1"){ connectWallet().catch(()=>updateUIDisconnected()); }

/* react to metamask events */
if(window.ethereum){
  window.ethereum.on("accountsChanged", (acc) => {
    if(acc.length===0){ disconnectWallet(); log("üîÑ Account removed -> disconnected"); }
    else { userAddress = acc[0]; provider && provider.getNetwork().then(n=>updateUIConnected(userAddress,n.chainId)); log("üîÑ accountsChanged: "+JSON.stringify(acc)); }
  });
  window.ethereum.on("chainChanged", (cid) => {
    const dec = (typeof cid === "string" && cid.startsWith("0x")) ? parseInt(cid,16) : cid;
    provider && provider.getNetwork().then(n=>updateUIConnected(userAddress||"unknown",dec));
    log("üîÑ chainChanged: "+cid+" ("+dec+")");
  });
}

/* Helpers */
function getContract(addr, abi){
  return new ethers.Contract(addr, abi, signer);
}

/* Hide approve buttons when native involved */
function checkNativeInputs(){
  const A = document.getElementById("pairTokenA").value.trim().toLowerCase();
  const B = document.getElementById("pairTokenB").value.trim().toLowerCase();
  const hide = (A === NATIVE_USDC.toLowerCase() || B === NATIVE_USDC.toLowerCase());
  document.getElementById("approveA").style.display = hide ? "none" : "inline-block";
  document.getElementById("approveB").style.display = hide ? "none" : "inline-block";
}
document.getElementById("pairTokenA").addEventListener("input", checkNativeInputs);
document.getElementById("pairTokenB").addEventListener("input", checkNativeInputs);
checkNativeInputs();

/* Create pair */
document.getElementById("createPairBtn").addEventListener("click", async () => {
  try{
    if(!signer){ alert("Connect wallet first"); return; }
    const A = document.getElementById("pairTokenA").value.trim();
    const B = document.getElementById("pairTokenB").value.trim();
    const f = getContract(FACTORY, FACTORY_ABI);
    const btn = document.getElementById("createPairBtn");
    setProcessing(btn, true, "Creating...");
    const tx = await f.createPair(A,B);
    log("‚è≥ createPair tx: " + tx.hash);
    await tx.wait();
    log("‚úÖ Pair created");
    setProcessing(btn, false);
  }catch(e){ setProcessing(document.getElementById("createPairBtn"), false); log("‚ùå createPair failed: "+(e.message||e)); }
});

/* Get pair */
document.getElementById("getPairBtn").addEventListener("click", async ()=>{
  try{
    const A = document.getElementById("pairTokenA").value.trim();
    const B = document.getElementById("pairTokenB").value.trim();
    const f = getContract(FACTORY, FACTORY_ABI);
    const pair = await f.getPair(A,B);
    document.getElementById("pairAddr").textContent = pair === ethers.ZeroAddress ? "Pair not found" : "Pair: " + pair;
    log("üîé Pair: " + pair);
  }catch(e){ log("‚ùå getPair failed: "+(e.message||e)); }
});

/* Approve helpers A/B */
document.getElementById("approveA").addEventListener("click", async ()=>{
  try{
    if(!signer){ alert("Connect wallet first"); return; }
    const a = document.getElementById("pairTokenA").value.trim();
    if(a.toLowerCase() === NATIVE_USDC.toLowerCase()){ alert("Token A is native USDC, no approve required."); return; }
    const amt = document.getElementById("amtA").value.trim();
    const erc = getContract(a, ERC20_ABI);
    const btn = document.getElementById("approveA");
    setProcessing(btn, true, "Approving A...");
    const tx = await erc.approve(ROUTER, amt);
    log("‚è≥ Approve A tx: " + tx.hash);
    await tx.wait();
    log("‚úÖ Approved A");
    setProcessing(btn, false);
  }catch(e){ setProcessing(document.getElementById("approveA"), false); log("‚ùå approveA failed: "+(e.message||e)); }
});

document.getElementById("approveB").addEventListener("click", async ()=>{
  try{
    if(!signer){ alert("Connect wallet first"); return; }
    const b = document.getElementById("pairTokenB").value.trim();
    if(b.toLowerCase() === NATIVE_USDC.toLowerCase()){ alert("Token B is native USDC, no approve required."); return; }
    const amt = document.getElementById("amtB").value.trim();
    const erc = getContract(b, ERC20_ABI);
    const btn = document.getElementById("approveB");
    setProcessing(btn, true, "Approving B...");
    const tx = await erc.approve(ROUTER, amt);
    log("‚è≥ Approve B tx: " + tx.hash);
    await tx.wait();
    log("‚úÖ Approved B");
    setProcessing(btn, false);
  }catch(e){ setProcessing(document.getElementById("approveB"), false); log("‚ùå approveB failed: "+(e.message||e)); }
});

/* Add liquidity (handles native USDC via addLiquidityNative) */
document.getElementById("addLpBtn").addEventListener("click", async ()=>{
  try{
    if(!signer){ alert("Connect wallet first"); return; }
    const A = document.getElementById("pairTokenA").value.trim();
    const B = document.getElementById("pairTokenB").value.trim();
    const a = document.getElementById("amtA").value.trim();
    const b = document.getElementById("amtB").value.trim();
    const r = getContract(ROUTER, ROUTER_ABI);
    const btn = document.getElementById("addLpBtn");
    setProcessing(btn, true, "Adding LP...");

    let tx;
    if (A.toLowerCase() === NATIVE_USDC.toLowerCase()) {
      // A is native -> call addLiquidityNative(token=B, amountToken=b) with value = a
      tx = await r.addLiquidityNative(B, b, { value: a });
    } else if (B.toLowerCase() === NATIVE_USDC.toLowerCase()) {
      // B is native -> call addLiquidityNative(token=A, amountToken=a) with value = b
      tx = await r.addLiquidityNative(A, a, { value: b });
    } else {
      // both ERC20
      tx = await r.addLiquidity(A,B,a,b);
    }

    log("‚è≥ addLiquidity tx: " + tx.hash);
    await tx.wait();
    log("‚úÖ Liquidity added");
    setProcessing(btn, false);
  }catch(e){ setProcessing(document.getElementById("addLpBtn"), false); log("‚ùå addLiquidity failed: "+(e.message||e)); }
});

/* Approve input for swap */
document.getElementById("approveSwapBtn").addEventListener("click", async ()=>{
  try{
    if(!signer){ alert("Connect wallet first"); return; }
    const dir = document.getElementById("swapDir").value;
    // decide which token is input for swap (if native, skip)
    const input = dir === "usdc->token" ? document.getElementById("pairTokenA").value.trim() : document.getElementById("pairTokenB").value.trim();
    if(input.toLowerCase() === NATIVE_USDC.toLowerCase()){ alert("Input is native USDC ‚Äî no approve required."); return; }
    const amt = document.getElementById("swapAmount").value.trim();
    const erc = getContract(input, ERC20_ABI);
    const btn = document.getElementById("approveSwapBtn");
    setProcessing(btn, true, "Approving...");
    const tx = await erc.approve(ROUTER, amt);
    log("‚è≥ Approve swap tx: " + tx.hash);
    await tx.wait();
    log("‚úÖ Approved for swap");
    setProcessing(btn, false);
  }catch(e){ setProcessing(document.getElementById("approveSwapBtn"), false); log("‚ùå approve swap failed: "+(e.message||e)); }
});

/* Swap */
document.getElementById("swapBtn").addEventListener("click", async ()=>{
  try{
    if(!signer){ alert("Connect wallet first"); return; }
    const dir = document.getElementById("swapDir").value;
    const amt = document.getElementById("swapAmount").value.trim();
    const tokenIn = dir === "usdc->token" ? document.getElementById("pairTokenA").value.trim() : document.getElementById("pairTokenB").value.trim();
    const tokenOut= dir === "usdc->token" ? document.getElementById("pairTokenB").value.trim() : document.getElementById("pairTokenA").value.trim();
    const r = getContract(ROUTER, ROUTER_ABI);
    const btn = document.getElementById("swapBtn");
    setProcessing(btn, true, "Swapping...");

    // if tokenIn is native USDC, this contract likely expects swap with value; we call swap(tokenIn, tokenOut, amountIn)
    // If router implements native-handling differently, you'll need to adjust.
    const tx = await r.swap(tokenIn, tokenOut, amt, { value: tokenIn.toLowerCase() === NATIVE_USDC.toLowerCase() ? amt : 0 });
    log("‚è≥ swap tx: " + tx.hash);
    await tx.wait();
    log("‚úÖ Swap executed");
    setProcessing(btn, false);
  }catch(e){ setProcessing(document.getElementById("swapBtn"), false); log("‚ùå swap failed: "+(e.message||e)); }
});

log("UI loaded ‚Äî minimal Uniswap-like. Router: " + ROUTER);
</script>
</body>
</html>
